# SOLID
Один из принципов проектирования ПО. Является аббревиатурой. Состоит из следующих частей:

## ``S``Принцип единой ответственности. 
- **у каждого класса должна быть только одна причина для его изменения.**

Для понимания - каждый класс выполняет только одну задачу. Если необходимо внести изменения в функционал, то сразу ясно в какую часть программы их внести, и есть уверенность, что эти изменения не затронут остальные части системы.

## ``O``Принцип открытости - закрытости.
- **программные сущности должны быть открыты для расширения, но закрыты для изменения**

#### Зачем это нужно?
В первую очередь это необходимо для тестов и общей целостности программы. Расширение функционала не затронет уже работающий код, не потребует переписывания тестов и изменения зависимых частей программы.

*Для понимания* - новый функционал вводится в классы-наследники базового интерфейса или уже работающих классов. В результате имеются зафиксированные интерфейсы с устоявшимся функционалом. Позволяет вести параллельную разработку. 

#### Например?

Есть метод, который принимает на вход некий объект, например ```foo(Student student)``` и далее, в зависимости от некоторых внутренних параметров студента срабатывает разная логика. Например:

```C#
if(student.Course == 3){
   foo1();
}
if(student.Name == "Sam"){
   foo2();
}
if(student.Age>25){
   foo3();
}
 ```
   
и этих ограничений на студента может быть сколько угодно. Они могут добавляться, изменяться и пр. На лицо видно нарушение принципа открытости/закрытости. Мы изменяем метод, а должны расширять базовый функционал.

#### Как это исправить? ####
Выделить отдельную сущность с правилами по которым обрабатываются студенты. Например 
```C#
List<IstudentRule> rules = new List<IstudentRule>();
rules.add(....)
..............
    
for(int i=0; i<rules.length; i++){
    rules[i].TryWork(student);
}
```
#### Что на выходе?

Расширяемый функционал, поддерживаемый код.

## ``L``Принцип Барбары Лисков
- **функции, использующие базовый тип должны уметь работать с подтипами, не зная об этом**
В первом приближении принцип выглядит так: мы можем создать объект класса потомка, использую объявление его предка, при этом все будет верно работать. ```AbstractFactory mobile = new MobileFactory(); mobile.Build("phone");```

#### Рассмотрим немного глубже. 
Для внесения ясности и понимания необходимо ввести 2 термина. ***Предусловие и постусловие***

- *предусловие* - условие, на входные данные. 
- *постусловие* - условие, нв выходные данные или состояние системы. 

*Наследуемый объект может заменить родительское пред-условие на такое же или более слабое и родительское пост-условие на такое же или более сильное.*

Например - для класса ```List``` существует некий контрактый метод. ```Add```. У него есть предусловие что добавляемые данные не должны быть ```null```. и постусловие - данные добавились в лист один раз. 

Таким образом мы можем создать собственный объект наследник над List, изменив метод ```Add```, заменив предусловие на то что можно добавлять пустые данные null. А постусловие оставить прежним - данные будут добавлены в лист. 

Если есть необходимость добавлять данные в лист по какому-то хитрому алгоритму (добавлять 2 раза, при добавлении удалять предыдущие) то мы не можем назвать такой функционал Add, ввиду того что постусловие будет ослаблено. А этого не должно происходить. При подобной необходимости лучше создать собственный отдельно стоящий List, не в цепочке наследования, который бы выполнял свобственные контракты на пред и пост условия.

## ``I``Принцип разделения интерфейсов

***Коротко*** - лучше несколько небольших интерфейсов, чем один монструозный. 

Исходить в данном принципе стоит от того, кто использует данный интефейс. Каждой сущности-пользователю необходимо предоставить только те данные (доступ к методам), без которых она(сущность) не сможет работать, и желательно закрыть данные, которые она(сущность) видеть не должна. 

## ``D``Принцип инверсии зависимостей. 
- Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба зависят от абстракции.
- Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. 

***О чем вообще речь?*** - Родительский класс не должен логически учитывать какие-то конкретные свои потомки. Т.е. есть объект - ```AbstractActor``` и он никак не должен знать что есть его наследник - ```BadGuyActor``` т.е. недопустимы проверки в ```AbstractActor``` на то - не является ли этот объект экземпляром ```BadGuyActor```.

Абстракции не должны создавать объекты без крайней на то необходимости. Объекты лучше инжектить в метод, по имени универсального интерфейса. Такой подход позволит протестировать части системы независимо друг от друга. 
	
    1. создать магазин тортов <Ishop>
    2. создать рецепт тора <Irecipe>
    3. создать все ингридиенты для торта <Iingredient>
    4. добавить ингридиенты в рецепт
    5. добавить рецепт в магазин
    6. заказать у магазина торт. 





